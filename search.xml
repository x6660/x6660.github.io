<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第四章 对象与类</title>
      <link href="/2020/03/19/dui-xiang-yu-lei/"/>
      <url>/2020/03/19/dui-xiang-yu-lei/</url>
      
        <content type="html"><![CDATA[<p>面向对象程序设计概述<br>使用预定义类<br>用户自定义类<br>静态字段与静态方法<br>方法参数<br>对象构造<br>包<br>JAR文件<br>文档注释<br>类设计技巧</p><p>这一章将主要介绍如下内容：<br>面向对象程序设计入门；<br>如何创建标准Java类库中类的对象；<br>如何编写自己的类。<br>如果你没有面向对象程序设计的应用背景，就一定要认真地阅读本章的内容。面向对象程序设计与面向过程的语言在思维方式上存在着很大的差别。改变思维方式并不是一件很容易的事情，但是为了继续学习Java，一定要掌握对象的概念。<br>对于有经验的C++程序员来说，与上一章逸雅阁，对本章的内容不会感到太陌生，但这两种语言还是存在着很多不同之处，所以要认真阅读本章的后半部分内容，你将发现“C++注释“对于你转换思维方式会很有帮助。</p><h2 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h2><p>面向对象程序设计（object-oriented programming,OOP)是当今主流的程序设计范型，它取代了20世纪70年代的”结构化“或过程式编程技术。由于Java是面向对象的，所以你必须熟悉OOP才能够很好地使用Java.<br>面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。究竟是自己构造对象，还是从外界购买对象完全取决于开发项目的预算和时间。但是，从根本上说，只要对象能够满足要求，就不必关心其功能到底是如何实现的。<br>传统的结构化程序设计通过一系列的过程（即算法）来求解问题。一旦确定了这些过程，就要开始考虑存储数据的适当方式。这就是Pascal语言的设计者Niklaus Wirth将其著作命名为《算法+数据结构=程序》（Algorithms + Data Structures = Programs,Prentice Hall,1975）的原因。需要注意的是，在Wirth的这个书名中，算法是第一位的，数据结构是第二位的，这就明确地表述了程序员的工作方式。首先要确定如何操作数据，然后再决定如何组织数据的结构，以便于操作数据。而OOP却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。<br>对于一些规模较小的问题，将其分解为过程的开发方式比较理想。面向对象更加适合解决规模较大的问题。要想实现一个简单的Web浏览器可能需要大约2000个过程，这些过程可能需要对一组全局数据进行操作。采用面向对象的设计风格，可能只需要大约100个类，每个类平均包含20个方法。后者更易于程序员掌握，也容易找到bug，假设给定对象的数据出错了，在访问这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。### 类<br>类（class）是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kwdmrsf</title>
      <link href="/2020/03/17/kwdmrsf/"/>
      <url>/2020/03/17/kwdmrsf/</url>
      
        <content type="html"><![CDATA[<h2 id="康威的末日算法"><a href="#康威的末日算法" class="headerlink" title="康威的末日算法"></a>康威的末日算法</h2><p>下面探讨第三题的答案。这道题并没有太多说明，只是问”2199年7月2日是星期几”.有些读者可能会将目光投向电脑屏幕右下角，想打开日历程序偷偷查看2199年的日期。对不起，Windows系统的日历程序只支持到2099年，并不显示之后的年份。</p><p>还是先公布答案吧，2199年7月2日是星期二。准确率是1/7，所以可以靠运气蒙一下。但要想真正求出正确答案，过程并不简单。也许有些读者（很少）会自己设计精妙算法求出答案，但我还是想通过约翰。康威教授的“末日算法”进行说明。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 末日算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qwerty</title>
      <link href="/2020/03/15/qwerty/"/>
      <url>/2020/03/15/qwerty/</url>
      
        <content type="html"><![CDATA[<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> oal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举服务</title>
      <link href="/2020/03/13/hello-world/"/>
      <url>/2020/03/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>枚举是一类程序，它允许用户从一个网络中收集某一类的所有相关信息。本节将介绍DNS枚举和SNMP枚举技术。DNS枚举可以收集本地所有DNS服务和相关条目。DNS枚举可以帮助用户收集目标组织的关键信息，如用户名、计算机名和IP地址等，为了获取这些信息，用户可以使用DNSenum工具。要进行SNMP枚举，用户需要使用SnmpEnum工具。SnmpEnum是一个强大的SNMP枚举工具，它允许用户分析一个网络内SNMP信息传输。</p><h2 id="DNS枚举工具DNSenum"><a href="#DNS枚举工具DNSenum" class="headerlink" title="DNS枚举工具DNSenum"></a>DNS枚举工具DNSenum</h2><p>DNSenum是一款非常强大的域名信息收集工具。它能够通过谷歌或者字典文件猜测可能存在的域名，并对一个网段进行反向查询。它不仅可以查询网站的主机地址信息、域名服务器和邮件交换记录，还可以在域名服务器上执行axfr请求，然后通过谷歌脚本得到扩展域名信息，提取子域名并查询，最后计算C类地址并执行whois查询，执行反向查询，把地址段写入文件。本小节将介绍使用DNSenum工具检查DNS枚举。在终端执行如下所示的命令：</p><pre class=" language-bash"><code class="language-bash">root@kali:~<span class="token comment" spellcheck="true"># dnsenum --enum benet.com</span></code></pre><p>输出的信息显示了DNS服务的详细信息。其中，包括主机地址、域名服务地址和邮件服务地址。如果幸运的话，还可以看到一个区域传输。</p><h3 id="使用DNSenum工具检查DNS枚举时，可以使用dnsenum的一些附加选项，如下所示。"><a href="#使用DNSenum工具检查DNS枚举时，可以使用dnsenum的一些附加选项，如下所示。" class="headerlink" title="使用DNSenum工具检查DNS枚举时，可以使用dnsenum的一些附加选项，如下所示。"></a>使用DNSenum工具检查DNS枚举时，可以使用dnsenum的一些附加选项，如下所示。</h3><p>–threads [number]：设置用户同时运行多个进程数。<br>-r：允许用户启用递归查询。<br>-d：允许用户设置WHOIS请求之间时间延迟数（单位为秒）。<br>-o：允许用户指定输出位置。<br>-w：允许用户启用WHOIS请求。</p><h2 id="DNS枚举工具fierce"><a href="#DNS枚举工具fierce" class="headerlink" title="DNS枚举工具fierce"></a>DNS枚举工具fierce</h2><p>fierce工具和DNSenum工具性质差不多，其fierce主要是对子域名进行扫描和收集信息的。使用fierce工具获取一个目标主机上所有IP地址和主机信息。执行命令如下所示：</p><pre class=" language-bash"><code class="language-bash">root@kali:~<span class="token comment" spellcheck="true"># fierce -dns baidu.com</span></code></pre><p>输出的信息显示了baidu.com下所有的子域。从倒数第2行，可以看到总共找到133个条目。执行以上命令后，输出的内容较多。但是由于篇幅的原因，部分内容使用省略号（……）取代。</p><h3 id="用户也可以通过提供一个单词列表执行相同的操作，执行命令如下所示："><a href="#用户也可以通过提供一个单词列表执行相同的操作，执行命令如下所示：" class="headerlink" title="用户也可以通过提供一个单词列表执行相同的操作，执行命令如下所示："></a>用户也可以通过提供一个单词列表执行相同的操作，执行命令如下所示：</h3><pre class=" language-bash"><code class="language-bash">root@kali:~<span class="token comment" spellcheck="true"># fierce -dns baidu.com -wordlist hosts.txt /tmp/output.txt</span></code></pre><h3 id="SNMP枚举工具Snmpwalk"><a href="#SNMP枚举工具Snmpwalk" class="headerlink" title="SNMP枚举工具Snmpwalk"></a>SNMP枚举工具Snmpwalk</h3><p>Snmpwalk是一个SNMP应用程序。它使用SNMP的GETNEXT请求，查询指定的所有OID（SNMP协议中的对象标识）树信息，并显示给用户。本小节将演示Snmpwalk工具的使用。</p><p>使用Snmpwalk命令测试Windows主机。执行命令如下所示：</p><pre class=" language-bash"><code class="language-bash">root@kali:~<span class="token comment" spellcheck="true"># snmpwalk -c public 192.168.41.138 -v 2c</span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 信息服务 </category>
          
          <category> 枚举服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 网络进程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
